* How To Reproduce

  Ensure the 32-bit RiscV ELF tools are in your =$PATH= and run =make=.
  The =Makefile= expects to find =riscv32-unknown-elf-gcc= and
  =riscv32-unknown-elf-gdb=.

  I've not testing this bug on 64-bit tools yet, but it doesn't feel
  like it should be 32-bit specific and will probably reproduce there
  too.

  The =Makefile= will build the test binary, and run =gdb=, at the end of
  the =gdb= output you'll see this:

  #+BEGIN_EXAMPLE
    +up
    #1  0x0001021c in wack_float (u=-2, v=-1) at store.c:20
    20        l = add_float (l, r);
    +print l
    $1 = 9.25921973e-41
    +set variable l = 0
    +continue
    sim: bad insn len 0x2 @ 0: 0

    Program terminated with signal SIGILL, Illegal instruction.
    The program no longer exists.
    +quit
  #+END_EXAMPLE

  The value if =l= should be -2, and =gdb= should not hit a SIGILL when it
  continues, both of these issues are caused by the same bug.

* Description Of Bug

  This test is based on gdb.base/store.exp from the GDB testsuite.

  In this test GDB runs to a frame and stops, then moves back up the
  frame stack using the =up= command.

  Once in the previous frame, GDB examines a local variable, and then
  modifies the local variable.  Finally GDB continues.

  The bug is that the location information in the DWARF for the local
  variable, generated by GCC, is incorrect.  As a result, GDB reads,
  and modifies the frames return address instead of the actual local
  variable value.

  The problem frame is this C function:

  #+BEGIN_SRC c
    float
    wack_float (register float u, register float v)
    {
      register float l = u, r = v;
      l = add_float (l, r);
      return l + r;
    }
  #+END_SRC

  The test is interested in the local variable =l=.  The DWARF for this
  function is:

  #+BEGIN_EXAMPLE
     <1><6c>: Abbrev Number: 4 (DW_TAG_subprogram)
        <6d>   DW_AT_external    : 1
        <6d>   DW_AT_name        : (indirect string, offset: 0x1c71): wack_float
        <71>   DW_AT_decl_file   : 1
        <72>   DW_AT_decl_line   : 17
        <73>   DW_AT_decl_column : 1
        <74>   DW_AT_prototyped  : 1
        <74>   DW_AT_type        : <0xb7>
        <78>   DW_AT_low_pc      : 0x101ec
        <7c>   DW_AT_high_pc     : 0x5c
        <80>   DW_AT_frame_base  : 1 byte block: 9c         (DW_OP_call_frame_cfa)
        <82>   DW_AT_GNU_all_tail_call_sites: 1
        <82>   DW_AT_sibling     : <0xb7>
     <2><86>: Abbrev Number: 5 (DW_TAG_formal_parameter)
        <87>   DW_AT_name        : u
        <89>   DW_AT_decl_file   : 1
        <8a>   DW_AT_decl_line   : 17
        <8b>   DW_AT_decl_column : 28
        <8c>   DW_AT_type        : <0xb7>
        <90>   DW_AT_location    : 1 byte block: 5e         (DW_OP_reg14 (a4))
     <2><92>: Abbrev Number: 5 (DW_TAG_formal_parameter)
        <93>   DW_AT_name        : v
        <95>   DW_AT_decl_file   : 1
        <96>   DW_AT_decl_line   : 17
        <97>   DW_AT_decl_column : 46
        <98>   DW_AT_type        : <0xb7>
        <9c>   DW_AT_location    : 1 byte block: 5f         (DW_OP_reg15 (a5))
     <2><9e>: Abbrev Number: 6 (DW_TAG_variable)
        <9f>   DW_AT_name        : l
        <a1>   DW_AT_decl_file   : 1
        <a2>   DW_AT_decl_line   : 19
        <a3>   DW_AT_decl_column : 18
        <a4>   DW_AT_type        : <0xb7>
        <a8>   DW_AT_location    : 1 byte block: 51         (DW_OP_reg1 (ra))
     <2><aa>: Abbrev Number: 6 (DW_TAG_variable)
        <ab>   DW_AT_name        : r
        <ad>   DW_AT_decl_file   : 1
        <ae>   DW_AT_decl_line   : 19
        <af>   DW_AT_decl_column : 25
        <b0>   DW_AT_type        : <0xb7>
        <b4>   DW_AT_location    : 1 byte block: 59         (DW_OP_reg9 (s1))
  #+END_EXAMPLE

  The local variable =l= is placed into register =ra=, the return address
  register.  Using the return address register as a general purpose
  frame local is not itself wrong, though it does seem like a strange
  choice in a non-leaf function, given that the function is hardly
  short on registers.

  Still, even if we made GCC less-likely to pick =ra=, we'd probably not
  want to prevent its use, so any issues uncovered here would still
  need to be addressed eventually.

  In the test GDB stops not in =wack_float=, but in =add_float=, and then
  moves =up= to =wack_float= in order to examine, and modify =l=.  The
  assembly code for =wack_float= looks like this:

  #+BEGIN_EXAMPLE
    Dump of assembler code for function wack_float:
       0x000101ec <+0>:     addi    sp,sp,-16
       0x000101f0 <+4>:     sw      ra,12(sp)
       0x000101f4 <+8>:     sw      s0,8(sp)
       0x000101f8 <+12>:    sw      s1,4(sp)
       0x000101fc <+16>:    addi    s0,sp,16
       0x00010200 <+20>:    mv      a4,a0
       0x00010204 <+24>:    mv      a5,a1
       0x00010208 <+28>:    mv      ra,a4
       0x0001020c <+32>:    mv      s1,a5
       0x00010210 <+36>:    mv      a1,s1
       0x00010214 <+40>:    mv      a0,ra
       0x00010218 <+44>:    jal     ra,0x101b0 <add_float>
    => 0x0001021c <+48>:    mv      ra,a0
       0x00010220 <+52>:    mv      a1,s1
       0x00010224 <+56>:    mv      a0,ra
       0x00010228 <+60>:    jal     ra,0x1028c <__addsf3>
       0x0001022c <+64>:    mv      a5,a0
       0x00010230 <+68>:    mv      a0,a5
       0x00010234 <+72>:    lw      ra,12(sp)
       0x00010238 <+76>:    lw      s0,8(sp)
       0x0001023c <+80>:    lw      s1,4(sp)
       0x00010240 <+84>:    addi    sp,sp,16
       0x00010244 <+88>:    ret
  #+END_EXAMPLE

  One slight problem with this test is that at the point we try to
  interact with =l= in =wack_float=, it could be considered dead.  Once
  the value of =l= has been passed as an argument to =add_float= the old
  value is no longer required, a new value for =l= is defined once
  =add_float= returns.

  However, the test is compiled at =-O0=, and so I'd expect GCC to take
  more care to leave the old value of =l= around, probably on the stack
  in order that it can be investigated.

  Whatever, solution is proposed, claiming that =l= is in =ra= after
  address 0x10218 is certainly wrong, at that point, the =ra= register
  is being used to hold the return address for the call to =add_float=.

* Desired Resolution

  Ideally, =l= would be placed into a location within =wack_float= that
  would survive the call to =add_float=, and the location within the
  DWARF would reflect this new location.  This would mean that within
  GDB, we could safely move =up= from =add_float= to =wack_float= and
  examine, and modify, the value of =l=.

  As a minimum, the location for =l= (in the DWARF) needs to be modified
  to reflect that there /is/ no location for =l= while the call is
  ongoing.  This would still result in the GDB test failing, but I
  think a good argument could be made that the test is wrong and
  should accept that =l= could be optimised out, even at =-O0=.
